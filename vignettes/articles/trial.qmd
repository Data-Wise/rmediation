---
title: "Testing New Fucntions"
format: 
  html:
    fig-width: 8
    fig-height: 4
    code-fold: false
    highlight: tango
execute: 
  eval: false
  message: false
  error: true
---


```{r}
library(tidyverse)
library(kableExtra)
library(RMediation)
library(mice)
library(lavaan)
library(OpenMx)
```



```{r}
data("HolzingerSwineford1939", package = "lavaan")
# Introduce missing data
df_complete <-
    na.omit(HolzingerSwineford1939[c("x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9")])
amp <- mice::ampute(df_complete, prop = 0.2, mech = "MAR")
data_with_missing <- amp$amp

# Perform multiple imputation
imputed_data <-
    mice::mice(
        data_with_missing,
        m = 3,
        maxit = 3,
        seed = 12345,
        printFlag = FALSE
    )
sem_data <-
    impute_sem(data = imputed_data, method = "lavaan")
model <- "
 visual  =~ x1 + x2 + x3
 textual =~ x4 + x5 + x6
 speed   =~ x7 + x8 + x9
 "

imputed_data |>
    impute_sem(method = "lavaan") |>
    run_sem(model = model)

imputed_data |>
    impute_sem(method = "lavaan") |>
    run_sem(model = model) |>
    pool_sem()
```

```{r}
data_complete <- mice::complete(imputed_data, action = "all")
sem_results <-
    data_complete |> purrr::map(lavaan::sem, model = model)
# Covert it to mice::mira object to be able to use pool function
sem_results <- mice::as.mira(sem_results) |> print()


``` 

```{r}
## Helper functions for pooling results from lavaan and OpenMx objects
## These functions should be customized based on the structure of your lavaan and OpenMx objects
## and the specific information you need to extract for pooling.

extract_lav <- function(fit,
                        conf.int = FALSE,
                        conf.level = 0.95) {
    # Extract the relevant information from a lavaan object
    # This function should be customized based on the structure of your lavaan objects
    # and the specific information you need to extract for pooling

    nimp <- length(fit)
    pooled_est <- fit |>
        purrr::map_dfr(broom::tidy, conf.int = conf.int, .id = "imp") |>
        dplyr::select(
            .data$term,
            .data$estimate,
            .data$std.error,
            .data$statistic,
            .data$p.value
        ) |>
        dplyr::group_by(.data$term) |>
        dplyr::summarise(
            q_est = mean(.data$estimate),
            bet_var = var(.data$estimate),
            w_var = sum(.data$std.error^2) / nimp
        ) |>
        dplyr::ungroup() |>
        dplyr::mutate(tot_var = .data$w_var + .data$bet_var * (1 + 1 / nimp))
    return(pooled_est)
}
```

```{r}
object <- sem_results

# Assuming a function to extract fit indices from a lavaan object
lapply(
    object@results,
    extract_lav,
) # Note: ensure the function names used here also follow snake_case convention




