---
title: "Testing New Fucntions"
format: 
  html:
    fig-width: 8
    fig-height: 4
    code-fold: false
    highlight: tango
execute: 
  eval: true
  message: false
  error: true
editor: 
  markdown: 
    wrap: 72
editor_options: 
  chunk_output_type: console
---

```{r}
library(tidyverse)
library(kableExtra)
library(RMediation)
library(mice)
library(lavaan)
library(OpenMx)
```



```{r}
data("HolzingerSwineford1939", package = "lavaan")
# Introduce missing data
df_complete <-
    na.omit(HolzingerSwineford1939[c("x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9")])
amp <- mice::ampute(df_complete, prop = 0.2, mech = "MAR")
data_with_missing <- amp$amp

# Perform multiple imputation
imputed_data <-
    mice::mice(
        data_with_missing,
        m = 5,
        maxit = 3,
        seed = 12345,
        printFlag = FALSE
    )
sem_data <-
    impute_sem(data = imputed_data, method = "lavaan")
model <- "
 visual  =~ x1 + x2 + x3
 textual =~ x4 + x5 + x6
 speed   =~ x7 + x8 + x9
 "
```


```{r}
extract_lav <- function(fit,
                        conf.int = FALSE,
                        conf.level = 0.95) {
    # Extract the relevant information from a lavaan object
    # This function should be customized based on the structure of your lavaan objects
    # and the specific information you need to extract for pooling

    nimp <- length(fit)
    pooled_est <- fit |>
        purrr::map_dfr(RMediation::tidy, conf.int = conf.int, .id = "imp") |>
        dplyr::select(
            term,
            estimate,
            std.error,
            statistic,
            p.value
        ) |>
        dplyr::group_by(term) |>
        dplyr::summarise(
            estimate = mean(estimate),
            bet_var = var(estimate),
            w_var = sum(std.error^2) / nimp
        ) |>
        dplyr::ungroup() |>
        dplyr::mutate(tot_var = w_var + bet_var * (1 + 1 / nimp), std.error = sqrt(tot_var)) |>
        dplyr::select(term, estimate, std.error, tot_var)
    return(pooled_est)
}
```

```{r}
# Produce SemResults object
res1 <- imputed_data |>
    impute_sem(method = "lavaan") |>
    run_sem(model = model)

res1@results |>
    purrr::map_df(tidy, .id = "imp") |>
    group_by(imp) |>
    nest()

est_df <- res1@results |>
    purrr::map_dfr(lavaan::coef) |>
    summarise(across(everything(), mean)) |>
    print()

var_b <- res1@results |>
    purrr::map_dfr(lavaan::coef) |>
    summarise(across(everything(), var)) |>
    mutate(across(everything(), \(x) x * (1 + 1 / length(res1@results)))) |>
    print()

var_b_cov <- res1@results |>
    purrr::map_dfr(lavaan::coef) |>
    cov() * (1 + 1 / length(res1@results))

var_b_cov |> str()
var_b_cov |> print()
var_b_cov |> class()

var_w_cov <- res1@results |>
    purrr::map(lavaan::vcov) |>
    reduce(`+`) / length(res1@results)

var_w_cov |> print()
var_w_cov |> class()
var_w_cov |> str()
```


```{r}
library(lavaan)
library(dplyr)
library(purrr)
library(broom)

process_model_results <- function(model_results) {
    # Assuming `model_results` is a list of lavaan or OpenMx model objects

    # 0. Tidy Data Frame of Coefficient Estimates, Standard Errors, etc.
    res_tidy_df <- model_results |>
        purrr::map_df(tidy, .id = "imp")

    est_df <- model_results |>
        dplyr::select(term, estimate) |>
        group_by(term) |>
        summarise(across(everything(), mean))

    # 1. Coefficient Estimates Data Frame
    coef_est_df <- map_dfr(model_results, lavaan::coef, .id = "imp") %>%
        group_by(imp) %>%
        summarise(across(everything(), mean))

    # 2. Standard Errors Data Frame
    sq_std_errors_df <- map_dfr(model_results, \(x) diag(lavaan::vcov(x)), .id = "imp") %>%
        group_by(imp) %>%
        summarise(across(everything(), mean))

    # 3. List of Within Covariance Matrix of the Coefficients
    within_cov_matrices <- map(model_results, vcov())
    mean_within_cov_matrix <- reduce(within_cov_matrices, `+`) / length(within_cov_matrices)

    # Combine into a list
    list(
        coefficient_estimates = coef_est_df,
        standard_errors = std_errors_df,
        within_covariance_matrix = mean_within_cov_matrix
    )
}

# Example usage:
# Assuming `res1` is a list of model results from either lavaan or OpenMx
result_objects <- process_model_results(res1@results)

# You can then access the data frame of coefficient estimates, standard errors, and the within covariance matrix like this:
estimates_df <- result_objects$coefficient_estimates
standard_errors_df <- result_objects$standard_errors
within_cov_matrix <- result_objects$within_covariance_matrix

```

```{r}
res1 <- imputed_data |>
    impute_sem(method = "lavaan") |>
    run_sem(model = model)

class(res1)
slotNames(res1)
res1@method
res1@results

res1@results[[1]] |> tidy()

requiredColumns <-
    c(
        "term",
        "estimate",
        "std.error",
        "statistic",
        "p.value"
    )

cols <- res1@results[[1]] |>
    tidy() |>
    colnames()

!all(requiredColumns %in% cols)
```

```{r}
res_pooled <- res1 |> pool_sem()
```


```{r}
data_complete <- mice::complete(imputed_data, action = "all")

str(data_complete)

sem_results <-
    data_complete |> purrr::map(lavaan::sem, model = model)
# Covert it to mice::mira object to be able to use pool function
# sem_results <- mice::as.mira(sem_results) |> print()
#
class(sem_results)
names(sem_results)
```
