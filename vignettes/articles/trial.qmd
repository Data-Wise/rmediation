---
title: "Testing New Fucntions"
format: 
  html:
    fig-width: 8
    fig-height: 4
    code-fold: false
    highlight: tango
execute: 
  eval: true
  message: false
  error: true
editor: 
  markdown: 
    wrap: 72
editor_options: 
  chunk_output_type: console
---

```{r}
library(tidyverse)
library(kableExtra)
library(RMediation)
library(mice)
library(lavaan)
library(OpenMx)
```



```{r}
data("HolzingerSwineford1939", package = "lavaan")
# Introduce missing data
df_complete <-
  na.omit(HolzingerSwineford1939[c("x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9")])
amp <- mice::ampute(df_complete, prop = 0.2, mech = "MAR")
data_with_missing <- amp$amp

# Perform multiple imputation
imputed_data <-
  mice::mice(
    data_with_missing,
    m = 5,
    maxit = 3,
    seed = 12345,
    printFlag = FALSE
  )
sem_data <-
  impute_sem(data = imputed_data, method = "lavaan")
model <- "
 visual  =~ x1 + x2 + x3
 textual =~ x4 + x5 + x6
 speed   =~ x7 + x8 + x9
 "
```


```{r}
extract_lav <- function(fit,
                        conf.int = FALSE,
                        conf.level = 0.95) {
  # Extract the relevant information from a lavaan object
  # This function should be customized based on the structure of your lavaan objects
  # and the specific information you need to extract for pooling

  nimp <- length(fit)
  pooled_est <- fit |>
    purrr::map_dfr(RMediation::tidy, conf.int = conf.int, .id = "imp") |>
    dplyr::select(
      term,
      estimate,
      std.error,
      statistic,
      p.value
    ) |>
    dplyr::group_by(term) |>
    dplyr::summarise(
      estimate = mean(estimate),
      bet_var = var(estimate),
      w_var = sum(std.error^2) / nimp
    ) |>
    dplyr::ungroup() |>
    dplyr::mutate(tot_var = w_var + bet_var * (1 + 1 / nimp), std.error = sqrt(tot_var)) |>
    dplyr::select(term, estimate, std.error, tot_var)
  return(pooled_est)
}
```

```{r}
# Produce SemResults object
res1 <- imputed_data |>
  impute_sem(method = "lavaan") |>
  run_sem(model = model)

res1@results |>
  purrr::map_df(tidy, .id = "imp") |>
  group_by(imp) |>
  nest()

est_df <- res1@results |>
  purrr::map_dfr(lavaan::coef) |>
  summarise(across(everything(), mean)) |>
  print()

var_b <- res1@results |>
  purrr::map_dfr(lavaan::coef) |>
  summarise(across(everything(), var)) |>
  mutate(across(everything(), \(x) x * (1 + 1 / length(res1@results)))) |>
  print()

var_b_cov <- res1@results |>
  purrr::map_dfr(lavaan::coef) |>
  cov() * (1 + 1 / length(res1@results))

var_b_cov |> str()
var_b_cov |> print()
var_b_cov |> class()

var_w_cov <- res1@results |>
  purrr::map(lavaan::vcov) |>
  reduce(`+`) / length(res1@results)

var_w_cov |> print()
var_w_cov |> class()
var_w_cov |> str()
```



```{r}
res1 <- imputed_data |>
  impute_sem(method = "lavaan") |>
  run_sem(model = model)

class(res1)
slotNames(res1)
res1@method
res1@results

res1@results[[1]] |> tidy()

requiredColumns <-
  c(
    "term",
    "estimate",
    "std.error",
    "statistic",
    "p.value"
  )

cols <- res1@results[[1]] |>
  tidy() |>
  colnames()

!all(requiredColumns %in% cols)
```

```{r}
res_pooled <- res1 |> pool_sem()
```


```{r}
data_complete <- mice::complete(imputed_data, action = "all")

str(data_complete)

sem_results <-
  data_complete |> purrr::map(lavaan::sem, model = model)
# Covert it to mice::mira object to be able to use pool function
# sem_results <- mice::as.mira(sem_results) |> print()
#
class(sem_results)
names(sem_results)
```
