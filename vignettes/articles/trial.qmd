---
title: "Testing New Fucntions"
format: 
  html:
    fig-width: 8
    fig-height: 4
    code-fold: false
    highlight: tango
execute: 
  eval: true
  message: false
  error: true
editor: 
  markdown: 
    wrap: 87
editor_options: 
  chunk_output_type: inline
---

```{r}
#| message = FALSE
library(tidyverse)
library(kableExtra)
library(RMediation)
library(mice)
library(lavaan)
library(OpenMx)
library(broom)
```



```{r}
data("HolzingerSwineford1939", package = "lavaan")
# Introduce missing data
df_complete <-
    na.omit(HolzingerSwineford1939[c("x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9")])
amp <- mice::ampute(df_complete, prop = 0.2, mech = "MAR")
data_with_missing <- amp$amp

# Perform multiple imputation
imputed_data <-
    mice::mice(
        data_with_missing,
        m = 5,
        seed = 12345,
        printFlag = FALSE,
        iclude = TRUE
    )

model_lav <- "
 visual  =~ x1 + x2 + x3
 textual =~ x4 + x5 + x6
 speed   =~ x7 + x8 + x9 "

fitempty <- sem(model_lav, data = data_with_missing, do.fit = FALSE)

fit <- sem(model_lav, data = data_with_missing)
is_lav_syntax(model_lav)
is_lav_syntax(fit)

sem(fit, data = data_with_missing, do.fit = FALSE)

sem(fit, data = data_with_missing)

sem_data <-
    set_sem(data = imputed_data, model_lav, conf.int = TRUE, conf.level = 0.95)

names(imputed_data)

imputed_data$m
imputed_data$data |> head()
mice::complete(imputed_data, 1) |> head()
```

```{r}
fit_sem <- function(model, original_data) {
    if (is_lav_syntax(model, quiet = TRUE)) {
        lavaan::sem(model, data = original_data)
    } else if (!is_fit(model) && inherits(model, "lavaan")) {
        lavaan::sem(model, data = original_data, do.fit = TRUE) # fit the model
    } else if (inherits(model, "mxModel") && !is_fit(model)) {
        model_n <-
            OpenMx::mxModel(model, mxData(original_data, type = "raw"))
        OpenMx::mxRun(model_n)
    } else {
        model
    }
}
```

```{r}
fit_sem(model_lav, data_with_missing)
fit_sem(fit, data_with_missing)
fit_sem(fitempty, data_with_missing)
```

```{r}
fit_model(model_lav, data_with_missing)
fit_model(fit, data_with_missing)
fit_model(fitempty, data_with_missing)
```


```{r}
#| label = "lavaan_options"

fit0 <- sem(model_lav, data = data_with_missing, do.fit = FALSE)
class(fit0)

fit_lav <- sem(model_lav, data = data_with_missing, do.fit = TRUE)

slotNames(fit0)

fit0@Options$do.fit

fit@ParTable
fit@vcov
parTable(fit)
parTable("vcov")

lavInspect(fit, what = "data", add.labels = TRUE) |> head()
lavNames(fit)
lavInspect(fit, what = "vcov")
lavTech(fit, what = "vcov", add.labels = TRUE) # This is useful
lav_opts <- lavInspect(fit0, what = "options", add.labels = TRUE)
lav_opts$test
lav_opts$do.fit
```


```{r}
extract_lav <- function(fit,
                        conf.int = FALSE,
                        conf.level = 0.95) {
    # Extract the relevant information from a lavaan object
    # This function should be customized based on the structure of your lavaan objects
    # and the specific information you need to extract for pooling

    nimp <- length(fit)
    pooled_est <- fit |>
        purrr::map_dfr(RMediation::tidy, conf.int = conf.int, .id = "imp") |>
        dplyr::select(
            term,
            estimate,
            std.error,
            statistic,
            p.value
        ) |>
        dplyr::group_by(term) |>
        dplyr::summarise(
            estimate = mean(estimate),
            bet_var = var(estimate),
            w_var = sum(std.error^2) / nimp
        ) |>
        dplyr::ungroup() |>
        dplyr::mutate(tot_var = w_var + bet_var * (1 + 1 / nimp), std.error = sqrt(tot_var)) |>
        dplyr::select(term, estimate, std.error, tot_var)
    return(pooled_est)
}
```

```{r}
# Produce SemResults object
res1 <- imputed_data |>
    set_sem(model_lav) |>
    run_sem()

extract_lav(res1@results)
```

```{r}
extract_table <- function(fit, conf.int = FALSE, conf.level = 0.95) {
    # Extract the relevant information from a lavaan object
    # This function should be customized based on the structure of your lavaan objects
    # and the specific information you need to extract for pooling

    nimp <- length(fit)
    fit |>
        purrr::map_df(tidy, .id = "imp") |>
        group_by(term) |>
        summarise(est = mean(estimate), var_b = var(estimate), var_w = mean(std.error^2), var_tot = var_w + var_b * (1 + 1 / length(res1@results)), se = sqrt(var_tot), p.value = exp(mean(log(p.value)))) |>
        dplyr::ungroup() |>
        dplyr::rename(estimate = est, std.error = se) |>
        dplyr::relocate(term, estimate, std.error, p.value, var_b, var_w, var_tot)
}

extract_table(res1@results)


```

```{r}
res1@estimate_df
res1@coef_df |> dplyr::select(select = -.imp)
```


```{r}

res1@results |>
    purrr::map_df(tidy, .id = "imp") |>
    group_by(term) |>
    summarise(est = mean(estimate), var_b = var(estimate), var_w = mean(std.error^2), var_tot = var_w + var_b * (1 + 1 / length(res1@results)), se = sqrt(var_tot), p.value = exp(mean(log(p.value)))) |>
    knitr::kable()

est_df <- res1@results |>
    purrr::map_dfr(lavaan::coef) |>
    summarise(across(everything(), mean))
est_df |> knitr::kable()


var_b <- res1@results |>
    purrr::map_dfr(lavaan::coef) |>
    summarise(across(everything(), var))

var_b_cov <- res1@results |>
    purrr::map_dfr(lavaan::coef) |>
    cov()

var_w_cov <- res1@results |>
    purrr::map(lavaan::vcov) |>
    reduce(`+`) / length(res1@results)

rbind(bet1 = diag(var_b_cov), bet2 = var_b, within = diag(var_w_cov)) |> knitr::kable()
```


```{r}
#| eval = FALSE
process_model_results <- function(model_results) {
    # Assuming `model_results` is a list of lavaan or OpenMx model objects

    # 0. Tidy Data Frame of Coefficient Estimates, Standard Errors, etc.
    res_tidy_df <- model_results |>
        purrr::map_df(tidy, .id = "imp")

    est_df <- model_results |>
        dplyr::select(term, estimate) |>
        group_by(term) |>
        summarise(across(everything(), mean))

    # 1. Coefficient Estimates Data Frame
    coef_est_df <- map_dfr(model_results, lavaan::coef, .id = "imp") %>%
        group_by(imp) %>%
        summarise(across(everything(), mean))

    # 2. Standard Errors Data Frame
    sq_std_errors_df <- map_dfr(model_results, \(x) diag(lavaan::vcov(x)), .id = "imp") %>%
        group_by(imp) %>%
        summarise(across(everything(), mean))

    # 3. List of Within Covariance Matrix of the Coefficients
    within_cov_matrices <- map(model_results, vcov())
    mean_within_cov_matrix <- reduce(within_cov_matrices, `+`) / length(within_cov_matrices)

    # Combine into a list
    list(
        coefficient_estimates = coef_est_df,
        standard_errors = std_errors_df,
        within_covariance_matrix = mean_within_cov_matrix
    )
}

# # Example usage:
# # Assuming `res1` is a list of model results from either lavaan or OpenMx
# result_objects <- process_model_results(res1@results)

# # You can then access the data frame of coefficient estimates, standard errors, and the within covariance matrix like this:
# estimates_df <- result_objects$coefficient_estimates
# standard_errors_df <- result_objects$standard_errors
# within_cov_matrix <- result_objects$within_covariance_matrix
```


```{r}
#| eval = FALSE
data_complete <- mice::complete(imputed_data, action = "all")

str(data_complete)

sem_results <-
    data_complete |> purrr::map(lavaan::sem, model = model)

class(sem_results)
names(sem_results)
```

# OpenMx Models

```{r}
# Load OpenMx package
library(OpenMx)

# Define your model
# For example, let's consider a simple SEM with two latent variables and observed variables
# Note: This is just an illustrative example; replace it with your actual model specification
data("HolzingerSwineford1939", package = "lavaan")
# Simple SEM model specification with OpenMx
manifestVars <- paste0("x", 1:9)
latVar <- c("visual", "textual", "speed")
model_mx <- mxModel("Simple SEM",
    type = "RAM",
    manifestVars = manifestVars,
    latentVars = latVar,
    mxPath(from = "visual", to = c("x1", "x2", "x3")),
    mxPath(from = "textual", to = c("x4", "x5", "x6")),
    mxPath(from = "speed", to = c("x7", "x8", "x9")),
    mxPath(from = manifestVars, arrows = 2),
    mxPath(from = latVar, arrows = 2, free = FALSE, values = 1.0),
    mxPath(from = "one", to = manifestVars, arrows = 1, free = FALSE, values = 0),
    mxPath(from = "one", to = latVar, arrows = 1, free = FALSE, values = 0),
    mxData(HolzingerSwineford1939, type = "raw")
)
#
# Fit the model
fit_mx <- mxRun(model_mx)
RMediation::tidy(fit_mx)

imxVerifyModel(model_mx)

slotNames(fit_mx)

fit_mx@.wasRun
```


```{r}
# Load OpenMx package
# Define your model
# For example, let's consider a simple SEM with two latent variables and observed variables
# Note: This is just an illustrative example; replace it with your actual model specification

model1 <- mxModel("good model",
    type = "RAM",
    manifestVars = c("x1", "x2", "x3"),
    latentVars = c("latent1", "latent2"),
    mxPath(from = "latent1", to = c("x1", "x2", "x3")),
    mxPath(from = "latent2", to = c("x1", "x2", "x3")),
    mxPath(from = "latent1", arrows = 2),
    mxPath(from = "latent2", arrows = 2)
)


inherits(model1, "try-error")
imxVerifyModel(model1)

# Check model syntax
try(check_model <- imxVerifyModel(model1))

str(check_model)

model1@.wasRun
```

# Switch function

```{r}
method <- "OpenMx"
vcov_sem <- switch(tolower(method),
    "lavaan" = lavaan::vcov,
    "openmx" = vcov,
    stop("Unsupported method specified: ", method)
)

coef_sem <- switch(tolower(method),
    "lavaan" = lavaan::coef,
    "openmx" = coef,
    stop("Unsupported method specified: ", method)
)
coef_sem(fit_mx)
vcov_sem(fit_mx)
```

# Test SemResults

```{r}
#create_mock_SemResults <- function(method) {
  # Create a mock SemResults object
  # Replace this with actual data or object creation as necessary
  # The `method` argument can be used to customize the mock object based on the method
  # (e.g., lavaan, OpenMx) for which the object is being created
  data(HolzingerSwineford1939, package = "lavaan")
  df_complete <-
    na.omit(HolzingerSwineford1939[c("x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9")])
  amp <- mice::ampute(df_complete, prop = 0.2, mech = "MAR")
  data_with_missing <- amp$amp

  # Perform multiple imputation
  imputed_data <-
    mice::mice(
      data_with_missing,
      m = 3,
      maxit = 3,
      seed = 12345,
      printFlag = FALSE
    )

  # lavaan method

  lav_model <- "
 visual  =~ x1 + x2 + x3
 textual =~ x4 + x5 + x6
 speed   =~ x7 + x8 + x9
 "
  # OpenMx method
  manifestVars <- c("x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9")
  latVar <- c("visual", "textual", "speed")
  mx_model <- mxModel(
    "SimpleModel",
    type = "RAM",
    manifestVars = manifestVars,
    latentVars = latVar,
    mxPath(
      from = "visual",
      to = c("x1", "x2", "x3"),
      values = 0.5,
      labels = "loadings"
    ),
    mxPath(from = "textual", to = c("x4", "x5", "x6")),
    mxPath(from = "speed", to = c("x7", "x8", "x9")),
    mxPath(from = manifestVars, arrows = 2),
    mxPath(
      from = latVar,
      arrows = 2,
      free = FALSE,
      values = 1.0
    ),
    mxPath(
      from = "one",
      to = manifestVars,
      arrows = 1,
      free = FALSE,
      values = 0
    ),
    mxPath(
      from = "one",
      to = latVar,
      arrows = 1,
      free = FALSE,
      values = 0
    )
  )

  # Run the models
  # imp_sem <- set_sem(imputed_data, mx_model)
   res_lav <-  set_sem(imputed_data, lav_model)
   
   res_lav |> run_sem()
    res_mx <- set_sem(imputed_data, mx_model) |> run_sem()


mock_lavaan_SemResults <- create_mock_SemResults(method = "lavaan")
mock_OpenMx_SemResults <- create_mock_SemResults(method = "OpenMx")

pooled_results_lavaan <- pool_sem(mock_lavaan_SemResults)
pooled_results_OpenMx <- pool_sem(mock_OpenMx_SemResults)

```

## testing idexing

```{r}
df_tidy1 <- tidy(res1@results[[1]])
names(df_tidy1)

idx_names <- which(names(df_tidy1) %in% c("std.error", "p.value", "conf.low", "conf.high")) |> print()

## sunsitue names that contain "." with "_"
names(df_tidy1)[idx_names] <- gsub("\\.", "\\_", names(df_tidy1)[idx_names])
names(df_tidy1)



sub("\.", "\_". names(df_tidy1)[idx_names])

names(df_tidy1)[idx_names] <- c("std_error", "p_value", "conf_low", "conf_high")

```