---
title: "Testing New Fucntions"
format: 
  html:
    fig-width: 8
    fig-height: 4
    code-fold: false
    highlight: tango
execute: 
  eval: true
  message: false
  error: true
editor: 
  markdown: 
    wrap: 87
editor_options: 
  chunk_output_type: inline
---

```{r}
#| message = FALSE
library(tidyverse)
library(kableExtra)
library(RMediation)
library(mice)
library(lavaan)
library(OpenMx)
library(broom)
```



```{r}
data("HolzingerSwineford1939", package = "lavaan")
# Introduce missing data
df_complete <-
    na.omit(HolzingerSwineford1939[c("x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9")])
amp <- mice::ampute(df_complete, prop = 0.2, mech = "MAR")
data_with_missing <- amp$amp

# Perform multiple imputation
imputed_data <-
    mice::mice(
        data_with_missing,
        m = 5,
        seed = 12345,
        printFlag = FALSE,
        iclude = TRUE
    )

model_lav <- "
 visual  =~ x1 + x2 + x3
 textual =~ x4 + x5 + x6
 speed   =~ x7 + x8 + x9 "
```


```{r}
#| label = "lavaan_options"

fit0 <- sem(model_lav, data = data_with_missing, do.fit = FALSE)
class(fit0)

fit_lav <- sem(model_lav, data = data_with_missing, do.fit = TRUE)

slotNames(fit0)

fit0@Options$do.fit

fit_lav@ParTable
fit_lav@vcov
parTable(fit_lav)

lavInspect(fit_lav, what = "data", add.labels = TRUE) |> head()
lavNames(fit_lav)
lavInspect(fit_lav, what = "vcov")
lavTech(fit_lav, what = "vcov", add.labels = TRUE) # This is useful
lav_opts <- lavTech(fit_lav, what = "options", add.labels = TRUE)
lav_opts$test
lav_opts$do.fit ## useful to check if the model was fitted
```


```{r}
extract_table <- function(fit, conf.int = FALSE, conf.level = 0.95) {
    # Extract the relevant information from a lavaan object
    # This function should be customized based on the structure of your lavaan objects
    # and the specific information you need to extract for pooling

    nimp <- length(fit)
    fit |>
        purrr::map_df(tidy, .id = "imp") |>
        group_by(term) |>
        summarise(est = mean(estimate), var_b = var(estimate), var_w = mean(std.error^2), var_tot = var_w + var_b * (1 + 1 / length(res1@results)), se = sqrt(var_tot), p.value = exp(mean(log(p.value)))) |>
        dplyr::ungroup() |>
        dplyr::rename(estimate = est, std.error = se) |>
        dplyr::relocate(term, estimate, std.error, p.value, var_b, var_w, var_tot)
}


```


```{r}
# Produce SemResults object
res1 <- imputed_data |>
    set_sem(model_lav) |>
    run_sem()

slotNames(res1)

res1@results |>
    purrr::map_df(tidy, .id = "imp") |>
    group_by(term) |>
    summarise(est = mean(estimate), var_b = var(estimate), var_w = mean(std.error^2), var_tot = var_w + var_b * (1 + 1 / length(res1@results)), se = sqrt(var_tot), p.value = exp(mean(log(p.value)))) |>
    knitr::kable()

est_df <- res1@results |>
    purrr::map_dfr(lavaan::coef) |>
    summarise(across(everything(), mean))
est_df |> knitr::kable()


var_b <- res1@results |>
    purrr::map_dfr(lavaan::coef) |>
    summarise(across(everything(), var))

var_b_cov <- res1@results |>
    purrr::map_dfr(lavaan::coef) |>
    cov()

var_w_cov <- res1@results |>
    purrr::map(lavaan::vcov) |>
    reduce(`+`) / length(res1@results)

rbind(bet1 = diag(var_b_cov), bet2 = var_b, within = diag(var_w_cov)) |> knitr::kable()
```


```{r}
#| eval = FALSE
process_model_results <- function(model_results) {
    # Assuming `model_results` is a list of lavaan or OpenMx model objects

    # 0. Tidy Data Frame of Coefficient Estimates, Standard Errors, etc.
    res_tidy_df <- model_results |>
        purrr::map_df(tidy, .id = "imp")

    est_df <- model_results |>
        dplyr::select(term, estimate) |>
        group_by(term) |>
        summarise(across(everything(), mean))

    # 1. Coefficient Estimates Data Frame
    coef_est_df <- map_dfr(model_results, lavaan::coef, .id = "imp") %>%
        group_by(imp) %>%
        summarise(across(everything(), mean))

    # 2. Standard Errors Data Frame
    sq_std_errors_df <- map_dfr(model_results, \(x) diag(lavaan::vcov(x)), .id = "imp") %>%
        group_by(imp) %>%
        summarise(across(everything(), mean))

    # 3. List of Within Covariance Matrix of the Coefficients
    within_cov_matrices <- map(model_results, vcov())
    mean_within_cov_matrix <- reduce(within_cov_matrices, `+`) / length(within_cov_matrices)

    # Combine into a list
    list(
        coefficient_estimates = coef_est_df,
        standard_errors = std_errors_df,
        within_covariance_matrix = mean_within_cov_matrix
    )
}

# # Example usage:
# # Assuming `res1` is a list of model results from either lavaan or OpenMx
# result_objects <- process_model_results(res1@results)

# # You can then access the data frame of coefficient estimates, standard errors, and the within covariance matrix like this:
# estimates_df <- result_objects$coefficient_estimates
# standard_errors_df <- result_objects$standard_errors
# within_cov_matrix <- result_objects$within_covariance_matrix
```

# OpenMx Models

```{r}
# Define your model
# For example, let's consider a simple SEM with two latent variables and observed variables
# Note: This is just an illustrative example; replace it with your actual model specification
data("HolzingerSwineford1939", package = "lavaan")
# Simple SEM model specification with OpenMx
manifestVars <- paste0("x", 1:9)
latVar <- c("visual", "textual", "speed")
model_mx <- mxModel("Simple SEM",
    type = "RAM",
    manifestVars = manifestVars,
    latentVars = latVar,
    mxPath(from = "visual", to = c("x1", "x2", "x3")),
    mxPath(from = "textual", to = c("x4", "x5", "x6")),
    mxPath(from = "speed", to = c("x7", "x8", "x9")),
    mxPath(from = manifestVars, arrows = 2),
    mxPath(from = latVar, arrows = 2, free = FALSE, values = 1.0),
    mxPath(from = "one", to = manifestVars, arrows = 1, free = FALSE, values = 0),
    mxPath(from = "one", to = latVar, arrows = 1, free = FALSE, values = 0),
    mxData(HolzingerSwineford1939, type = "raw")
)
#
# Fit the model
fit_mx <- mxRun(model_mx)
tidy(fit_mx)

imxVerifyModel(model_mx)

slotNames(fit_mx)

fit_mx@.wasRun

is_fit(fit_mx)
```


```{r}
# Load OpenMx package
# Define your model
# For example, let's consider a simple SEM with two latent variables and observed variables
# Note: This is just an illustrative example; replace it with your actual model specification

model1 <- mxModel("good model",
    type = "RAM",
    manifestVars = c("x1", "x2", "x3"),
    latentVars = c("latent1", "latent2"),
    mxPath(from = "latent1", to = c("x1", "x2", "x3")),
    mxPath(from = "latent2", to = c("x1", "x2", "x3")),
    mxPath(from = "latent1", arrows = 2),
    mxPath(from = "latent2", arrows = 2)
)


inherits(model1, "try-error")
imxVerifyModel(model1)
is_fit(model1)
```

# Switch function

```{r}
method <- "openmx"
vcov_sem <- switch(tolower(method),
    "lavaan" = lavaan::vcov,
    "openmx" = vcov,
    stop("Unsupported method specified: ", method)
)

coef_sem <- switch(tolower(method),
    "lavaan" = coef,
    "openmx" = coef,
    stop("Unsupported method specified: ", method)
)
coef_sem(fit_mx)
vcov_sem(fit_mx)
```

# Test SemResults

```{r}
# create_mock_SemResults <- function(method) {
# Create a mock SemResults object
# Replace this with actual data or object creation as necessary
# The `method` argument can be used to customize the mock object based on the method
# (e.g., lavaan, OpenMx) for which the object is being created
data(HolzingerSwineford1939, package = "lavaan")
df_complete <-
    na.omit(HolzingerSwineford1939[c("x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9")])
amp <- mice::ampute(df_complete, prop = 0.2, mech = "MAR")
data_with_missing <- amp$amp

# Perform multiple imputation
imputed_data <-
    mice::mice(
        data_with_missing,
        m = 3,
        maxit = 3,
        seed = 12345,
        printFlag = FALSE
    )

# lavaan method

lav_model <- "
 visual  =~ x1 + x2 + x3
 textual =~ x4 + x5 + x6
 speed   =~ x7 + x8 + x9
 "
# OpenMx method
manifestVars <- c("x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9")
latVar <- c("visual", "textual", "speed")
mx_model <- mxModel(
    "SimpleModel",
    type = "RAM",
    manifestVars = manifestVars,
    latentVars = latVar,
    mxPath(
        from = "visual",
        to = c("x1", "x2", "x3"),
        values = 0.5,
        labels = "loadings"
    ),
    mxPath(from = "textual", to = c("x4", "x5", "x6")),
    mxPath(from = "speed", to = c("x7", "x8", "x9")),
    mxPath(from = manifestVars, arrows = 2),
    mxPath(
        from = latVar,
        arrows = 2,
        free = FALSE,
        values = 1.0
    ),
    mxPath(
        from = "one",
        to = manifestVars,
        arrows = 1,
        free = FALSE,
        values = 0
    ),
    mxPath(
        from = "one",
        to = latVar,
        arrows = 1,
        free = FALSE,
        values = 0
    )
)

# Run the models
# imp_sem <- set_sem(imputed_data, mx_model)
res_lav <- set_sem(imputed_data, lav_model)

res_lav |> run_sem()
res_mx <- set_sem(imputed_data, mx_model) |> run_sem()

```

## testing idexing

```{r}
df_tidy1 <- tidy(res1@results[[1]])
names(df_tidy1)

idx_names <- which(names(df_tidy1) %in% c("std.error", "p.value", "conf.low", "conf.high")) |> print()

## sunsitue names that contain "." with "_"
names(df_tidy1)[idx_names] <- gsub("\\.", "\\_", names(df_tidy1)[idx_names])
names(df_tidy1)

```
